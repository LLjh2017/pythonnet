2018 10.12   星期五




1.网络编程
2.进程线程
3.正则表达式
4.mongodb数据库
6.git使用
7.项目

网络编程
网络功能：数据的传输
ISO(国际标准化组织)

OSI七层模型---》网络通信工作流程标准化
  应用层：提供用户服务,具体功能有具体程序体现
  表示层：提供数据的压缩优化加密
  会话层：建立应用级的连接,选择适当的传输服务
  传输层：提供传输服务,流量控制
  网络层：路由选择,网络互连
  链路层：进行数据交换,控制具体消息的发送链路连接
  物理层：提供了数据传输的硬件保证,网卡,接口设置,传输介质

OSI七层模型优点
  1.建立了统一的工作流程
  2.分步清晰每一步各司其职
  3.降低了通信模块的耦合度

cookie 
  高内聚：模块的功能尽可能单一,不要互相掺杂
  低耦合：模块之间的关联影响尽可能少

四层模型(TCP/IP模型)
  应用层 
  传输层 
  网络层 
  物理链路层
  将应用层,表示层,会话层功能统一由应用层完成与应用开发 

五层模型
  应用层 传输层 网络层 链路层 物理层

数据的传输流程
  1.发送端由应用层到物理层逐层添加首部信息,最终在物理层
    发送信息包
  2.发送的信息中间经过多个结点传送(路由基站交换机等)
    最终到达目标主机
  3.目标主机逐层解析消息包,最终由应用层呈现数据信息

网络协议：
  网络通信中双方都遵循的规定,包括建立什么样的数据结构
  消息结构等

网络编程概念
  网络主机:在网络中标识一台计算机 host

  本地使用:'localhost'
          '127.0.0.1'
  网络使用:'0.0.0.0'
          '172.88.12.219'
ifconfig:查看本机的 IP 信息

获取计算机名
  In [2]: socket.gethostname()
  Out[2]: 'tedu'

获取计算机的网络地址
  In [4]: socket.gethostbyname('localhost')
  Out[4]: '127.0.0.1'

IP地址：
  在网络上确定一台主机的网络路由位置
IPv4 : 点分十进制 192.168.1.2  0~255
IPv6 : 128位
ping IP : 连接测试命令(能ping通可以连接)

特殊IP  
127.0.0.1 本机测试IP 
0.0.0.0   使用本机能够使用的网卡地址
192.168.56.0    表达一个网段
192.168.56.1    通常标识网关地址
192.168.56.255  广播地址

域名
  网络服务器地址的别名 www.baidu.com(域名)
  In [9]: socket.gethostbyname('www.baidu.com')
  Out[9]: '220.181.112.147'
  1.方便记忆
  2.表达一定的含义

端口号  port
  端口是网络地址的一部分,用于区分网络主机上不同的网络应用程序
  在一个系统中应用监听的端口号不能重复
  取值范围： 1~65535 
    1~255  一些众所周知的的公共程序端口
    256～1023  系统应用端口
    1024~65535 自用端口
获取一个应用端口 
  In [12]: socket.getservbyname('mysql')
  Out[12]: 3306



传输层服务 
面向连接的传输服务(基于tcp的数据传输)
  传输特征：提供可靠的数据传输,可靠性指数据传输过程中无丢失
          无失序,无差错,无重复
  实现手段：在通信前需要建立数据连接,通信结束要正常断开连接

  连接(三次握手)
    1.客户端向服务器发送连接标志变量表示请求连接
    2.服务器收到请求后,回复变量标志确定可连接
    3.客户端收到回复,发送最终连接标志建立连接

  断开连接(四次挥手)
    1.主动方发送标志表示请求断开连接
    2.被动方收到请求后立即回复信息表示已经接受请求
    3.被动方消息处理完毕再次发送标志表示已经准备可以断开
    4.主动方收到被动方标志,发送最终断开标识,连接断开

  适用情况：对数据准确性有明确要求,传输数据文件较大
          需要确保可靠性传输的情况
  比如：网页获取 文件下载 邮件收发等

面向无连接的传输服务(基于UDP协议的传输)
  传输特点：不保证传输的可靠性,传输过程中没有连接和断开
          的过程,数据自由收发
  适用情况：网络较差,对传输可靠性要求不高,如果使用tcp
          效率较低
  比如：网络视频 群聊 广播 
  
要求 
  1.OSI七层模型介绍一下 tcp/ip 模型是什么
  2.tcp服务和udp服务有什么异同
  3.三次握手和四次挥手是什么,过程是怎样的


socket模块
  套接字：实现网络编程,进行数据传输的一种技术手段
  使用socket模块提供的接口函数进行组合搭配,完成网络套接字
  编程
  套接字分类
    流式套接字 (SOCK_STREAM)： TCP 传输
    数据报套接字(SOCK_DGRAM) : UDP 传输
    面向连接--tcp协议--可靠地--流式套接字
    面向无连接--udp协议--不可靠--数据报套接字

tcp套接字编程
  服务端流程 
    1.创建套接字 
      sockfd=socket.socket(socket_family=AF_INET,
                           socket_type=SOCK_STREAM,
                           proto=0)
      功能：创建套接字
      参数：socket_family   地址族类型
                          AF_INET--->IPV4 
          socket_type     套接字类型 
                          SOCK_STREAM 流式套接字
                          SOCK_DGRAM  数据报套接字
          proto           通常为0

    返回值： 返回套接字对象

    2.绑定地址
      sockfd.bind(addr)
      功能：绑定本机的网络地址
      参数：元组(ip,port) 

    3.设置监听
      sockfd.listen(n)
      功能：将套接字设置为监听套接字并且创建监听队列
      参数：n 设置监听队列的大小

    4.等待处理客户端连接请求
      connfd,addr = sockfd.accept()
      功能：阻塞等待处理客户端请求
      返回值： connfd 连接的客户端的连接套接字
              addr   连接的客户端的地址
      阻塞函数：程序运行过程中遇到阻塞函数则暂停执行
              直到达成某种条件后再继续执行

    5.收发消息
      data=connfd.recv(buffersize)
      功能：接收消息
      参数：每次最多接收多少字节消息
      返回值：接收到的网络消息

      n=connfd.send(data)
      功能：发送消息
      参数：要发送的内容  bytes格式
      返回值：发送了多少个字节

    6.关闭套接字
      sockfd.close()
      功能：关闭套接字

import socket  

# 创建套接字
sockfd=socket.socket(socket.AF_INET,
                     socket.SOCK_STREAM)
# 设置绑定地址
sockfd.bind(('0.0.0.0',8888))

# 设置监听
sockfd.listen(5)

print("Waiting for connect...")
# 等待处理客户端连接
connfd,addr=sockfd.accept()
print('Connect from',addr) # 客户端地址

# 收发消息
data=connfd.recv(1024)
print("Receive message",data.decode())

n=connfd.send('Receive your msg\n'.encode())
print('Send %d bytes'%n)

# 关闭套接字
connfd.close()
sockfd.close()


  客户端 
    1.创建套接字
      只有相同类型的套接字才能进行连接传输
    2.请求连接
      sockfd.connect(server_addr)
      功能：连接服务端
      参数：服务器地址(元组)
    3.收发消息
      防止两端都阻塞,收发函数使用要配合
    4.关闭套接字

from socket import *

# 创建套接字
sockfd=socket()

# 发起链接
server_addr=('127.0.0.1',8888)
sockfd.connect(server_addr)

# 发收消息
data=input('>>')
sockfd.send(data.encode())
data=sockfd.recv(1024)
print("From server:",data.decode())

sockfd.close()


作业 
  将tcp两个程序改写成可以循环发送接收消息
  复习文件处理open
